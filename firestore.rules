/**
 * @file Firestore Security Rules
 * @core_philosophy This ruleset enforces a strict user-ownership model for user-specific data (shopping carts and user profiles) and allows public read access to product, category, and artist information.
 * @data_structure
 *  - /products/{productId}: Public product listings.
 *  - /categories/{categoryId}: Public product categories.
 *  - /artists/{artistId}: Public artist profiles.
 *  - /users/{userId}: User profile information, accessible only by the user.
 *  - /users/{userId}/shoppingCarts/{cartId}: Shopping carts owned by a specific user.
 * @key_security_decisions
 *  - Public read access for products, categories, and artists.
 *  - Strict ownership for user profiles and shopping carts.
 *  - Users can only manage their own shopping carts.
 *  - User listing is not allowed.
 * @denormalization_for_authorization Shopping carts include the `userId` to allow for authorization checks without needing to fetch the user document.
 * @structural_segregation User-owned shopping carts are stored in a user-specific subcollection (`/users/{userId}/shoppingCarts/{cartId}`) to simplify access control.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows public read access to product information. Only owners can create, update, or delete products.
     * @path /products/{productId}
     * @allow (get, list)
     * @deny (create, update, delete)
     * @principle Allows public read access and restricts write access to owners only.
     */
    match /products/{productId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      // CRITICAL: Cannot implement owner-only writes. The 'Product' entity is missing an 'ownerId' or 'authorId' field.
    }

    /**
     * @description Allows public read access to category information. Only owners can create, update, or delete categories.
     * @path /categories/{categoryId}
     * @allow (get, list)
     * @deny (create, update, delete)
     * @principle Allows public read access and restricts write access to owners only.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      // CRITICAL: Cannot implement owner-only writes. The 'Category' entity is missing an 'ownerId' or 'authorId' field.
    }

    /**
     * @description Allows public read access to artist information. Only owners can create, update, or delete artists.
     * @path /artists/{artistId}
     * @allow (get, list)
     * @deny (create, update, delete)
     * @principle Allows public read access and restricts write access to owners only.
     */
    match /artists/{artistId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      // CRITICAL: Cannot implement owner-only writes. The 'Artist' entity is missing an 'ownerId' or 'authorId' field.
    }

    /**
     * @description Allows a user to manage their own shopping carts.
     * @path /users/{userId}/shoppingCarts/{cartId}
     * @allow (create, get, list, update, delete) User with ID {userId} can (create, get, list, update, delete) cart with ID {cartId} if request.auth.uid == userId.
     * @deny (create, get, list, update, delete) User with ID {otherUserId} can't (create, get, list, update, delete) cart with ID {cartId} if request.auth.uid != userId.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/shoppingCarts/{cartId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows a user to manage their own profile.
     * @path /users/{userId}
     * @allow (create, get, update, delete) User with ID {userId} can (create, get, update, delete) profile with ID {userId} if request.auth.uid == userId.
     * @deny (create, get, update, delete) User with ID {otherUserId} can't (create, get, update, delete) profile with ID {userId} if request.auth.uid != userId.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // User listing is not allowed.
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Denies access to settings/socialMedia document as the authenticated user lacks the necessary permissions.
     * @path /settings/socialMedia
     * @allow
     * @deny (get) User with ID 7eTHLSxAfUU7B7vltr8TvXeosD23, email az9589317@gmail.com, and role user cannot get the document.
     * @principle Explicitly denies unauthorized access.
     */
    match /settings/socialMedia {
      allow get, list, create, update, delete: if false;
    }

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }
  }
}