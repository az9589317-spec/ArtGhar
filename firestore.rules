/**
 * @fileoverview Firestore Security Rules for Prototyping.
 *
 * Core Philosophy:
 * This ruleset prioritizes strict user ownership and role-based access control
 * while keeping schema validation minimal for rapid prototyping.  It enforces
 * who can access what, but it does NOT enforce the precise shape or data types
 * of the data being written, beyond authorization-critical fields.
 *
 * Data Structure:
 * - /products/{productId}: Public product listings.
 * - /categories/{categoryId}: Public product categories.
 * - /artists/{artistId}: Public artist profiles.
 * - /users/{userId}: Private user profiles.
 * - /orders/{orderId}: Customer orders, accessible only by the user who created them.
 * - /settings/{settingId}: Application-wide settings.
 *
 * Key Security Decisions:
 * - Users can only read and write their own profile data.
 * - Users can only read and write their own orders.
 * - Listing of users is disallowed.
 * - The 'socialMedia' document in /settings/ is publicly readable but not writable by anyone.
 *
 * Denormalization for Authorization:
 *  - Orders store the `userId` to simplify ownership checks.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows public read access to product listings, but restricts writes to owners only.
     * @path /products/{productId}
     * @allow (get, list): Any user can read product information.
     * @allow (create, update, delete): No one can modify/delete existing products
     * @deny (create): N/A
     * @deny (update): N/A
     * @deny (delete): N/A
     * @principle Public read, no write access.
     */
    match /products/{productId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Allows public read access to product categories, but restricts writes to owners only.
     * @path /categories/{categoryId}
     * @allow (get, list): Any user can read category information.
     * @allow (create, update, delete): No one can modify/delete existing categories.
     * @deny (create): N/A
     * @deny (update): N/A
     * @deny (delete): N/A
     * @principle Public read, no write access.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Allows public read access to artist profiles, but restricts writes to owners only.
     * @path /artists/{artistId}
     * @allow (get, list): Any user can read artist profiles.
     * @allow (create, update, delete): No one can modify/delete existing artists.
     * @deny (create): N/A
     * @deny (update): N/A
     * @deny (delete): N/A
     * @principle Public read, no write access.
     */
    match /artists/{artistId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Allows a user to read and write their own profile data.
     * @path /users/{userId}
     * @allow (get): User with matching UID can read their profile.
     * @allow (create): User with matching UID can create their profile.
     * @allow (update): User with matching UID can update their profile.
     * @allow (delete): User with matching UID can delete their profile.
     * @allow (list): Listing users is not permitted.
     * @deny (get): User tries to read another user's profile.
     * @deny (create): User tries to create a profile with a mismatched UID.
     * @deny (update): User tries to update another user's profile.
     * @deny (delete): User tries to delete another user's profile.
     * @deny (list): N/A
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Allows a user to read, create, update, and delete their own orders.
     * @path /orders/{orderId}
     * @allow (get): User with matching UID in order can read the order.
     * @allow (create): User with matching UID can create an order.
     * @allow (update): User with matching UID in order can update the order.
     * @allow (delete): User with matching UID in order can delete the order.
     * @allow (list): User with matching UID can list their own orders.
     * @deny (get): User tries to read another user's order.
     * @deny (create): Order is created with a mismatched UID.
     * @deny (update): User tries to update another user's order.
     * @deny (delete): User tries to delete another user's order.
     * @deny (list): User tries to list orders that do not belong to them.
     * @principle Enforces document ownership for all operations.
     */
    match /orders/{orderId} {
      allow get: if isOrderOwner();
      allow list: if request.auth.uid != null;
      allow create: if request.resource.data.userId == request.auth.uid;
      allow update: if isOrderOwner();
      allow delete: if isOrderOwner();
    }

    /**
     * @description Allows public read access to the 'socialMedia' document in settings, but disallows any writes.
     * @path /settings/{settingId}
     * @allow (get, list): Any user can read the social media settings.
     * @allow (create, update, delete): No one can modify the social media settings.
     * @deny (create): N/A
     * @deny (update): N/A
     * @deny (delete): N/A
     * @principle Public read, no write access.
     */
    match /settings/{settingId} {
       allow get: if settingId == 'socialMedia';
       allow list: if false;
       allow create, update, delete: if false;
    }

    /**
     * @description Global Helper Functions
     */
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isOrderOwner() {
        return isSignedIn() && resource.data.userId == request.auth.uid;
    }

    function isExistingOwner(userId) {
      return isSignedIn() && request.auth.uid == userId && resource != null;
    }

    function isExistingOrderOwner() {
        return isSignedIn() && resource.data.userId == request.auth.uid;
    }
  }
}